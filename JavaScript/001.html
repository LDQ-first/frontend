<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../style/default.css">
    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
</head>
<body>
<x-markdown>

# 导航

* [返回Github](https://github.com/LDQ-first/frontend)
* [返回首页](../index.html)



## JavaScript


### 介绍js的基本数据类型。

```
  Undefined、Null、Boolean、Number、String、
  ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )

```

### 复杂数据类型

```
Array, Object, Function

```

### 介绍js有哪些内置对象？

```
 Object 是 JavaScript 中所有对象的父对象

 数据封装类对象：Object、Array、Boolean、Number 和 String
 其他对象：Function、Arguments、Math、Date、RegExp、Error
```


### typeof && instanceof

```
typeof

typeof 0
"number"

typeof '0'
"string"

typeof undefined
"undefined"

typeof null
"object"

typeof {}
"object"

typeof []
"object"

typeof function () {}
"function"

typeof Symbol()
"symbol"




instanceof 


new Number() instanceof Number
true

new String() instanceof String
true

new Function() instanceof Function 
true

new Date() instanceof Date 
true

new RegExp() instanceof RegExp 
true

new Error() instanceof Error 
true

new Object() instanceof Object 
true

new Array () instanceof Array 
true

new Boolean() instanceof Boolean
true




Function instanceof Function
true

Object instanceof Object 
true

Object instanceof Function
true

Function instanceof Object
true

Array instanceof Array 
false


```


![001](../Img/type/001.jpg)


### 类型识别

```
typeof
   typeof可以识别标准类型null除外
   typeof不能识别具体的对象类型除了function外
 
 Object.prototype.toString
   Object.prototype.toString可以识别出标准类型以及所有的内置对象类型
   Object.prototype.toString不能识别自定义对象

 constructor
   constructor可以识别标准类型（undefined、null除外因为没有构造器）
   constructor可以识别内置对象类型
   constructor可以识别自定义对象类型

 instanceof
    instanceof 可以判别内置对象
    instanceof 不能判别基本类型
    instanceof 可以判别自定义对象
```




### JavaScript有几种类型的值？，你能画一下他们的内存图吗？

```

 栈：原始数据类型（Undefined，Null，Boolean，Number、String）
 堆：引用数据类型（对象、数组和函数）

 两种类型的区别是：存储位置不同；
 原始数据类型直接存储在栈(stack)中的简单数据段，
 占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；

 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。
 如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，
 该指针指向堆中该实体的起始地址。
 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体

```

![001](../Img/var/001.gif)



###  document.write 作用

```

当你打开一个页面，浏览器会

1 调用 document.open() 打开文档
2 document.write(...) 将下载到的网页内容写入文档
3 所有内容写完了，就调用 document.close()
4 触发 dom ready 事件（DOMContentReady)

所以你如果在第3步之前 document.write(1) 那么你就直接追加内容到当前位置，
如果你在第3步之后 document.write()，那么由于 document 已经 close 了，
所以必须重新 document.open() 来打开文档，这一打开，内容就被清空了。


```


### 为什么 0.1 + 0.2 结果为 0.30000000000000004

```

0.1 + 0.2
0.30000000000000004


需要有以下基础知识：

计算机将所有数据以二进制的形式存储
计算机用有限的大小来存储数据（因为现实生活中不存在无限大的内存或硬盘）

好的，然后结合我们的问题来看。


计算机如何存储 0.1 和 0.2？

十进制的 0.1 转为二进制，得到一个无限循环小数：0.00011…。

也就是说，二进制无法「用有限的位数」来表示 0.1。对于 0.2 也是一样的，不赘述。
二进制能「用有限的位数」表示的有：0.5、0.25、0.125 等。

但是计算机只能用有限的位数来存一个数，所以最终，计算机存的数是一个近似于 0.1 的小数。

确切的二进制值是0-01111111011-1001100110011001100110011001100110011001100110011010，
对应的十进制值是0.10000000000000000555...。


这是计算机能表示的最接近 0.1 的数字（存储一个数字的空间越大则越精确）。
（具体转换过程参考 https://segmentfault.com/a/1190000005022170 ）

所以当我们计算 0.1 + 0.2 时，实际上算的是两个近似值相加，得到的值当然也是近似等于 0.3。

总结

问题的根源是十进制小数转为二进制小数的过程中，会损失精度
你在写代码的过程中，遇到小数都要小心，比如下面的代码会造成死循环

var i = 0.1
while(i!=1){
    console.log(i)
    i += 0.1
}

因为 i 加 9 次 0.1，得到的值是 1 的近似值，并不是 1。
你应该对计算机存储方式有一定的了解。


```



![进制](../Img/二进制/001.png)











### null，undefined 的区别？

```

 null 		表示一个对象是“没有值”的值，也就是值为“空”；
 undefined 	表示一个变量声明了没有初始化(赋值)；

 undefined不是一个有效的JSON，而null是
 undefined的类型(typeof)是undefined
 null的类型(typeof)是object


 Javascript将未赋值的变量默认值设为undefined；
 Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。

 typeof undefined
 	//"undefined"
 	undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；
 	例如变量被声明了，但没有赋值时，就等于undefined

 typeof null
 	//"object"
 	null : 是一个对象(空对象, 没有任何属性和方法)；
 	例如作为函数的参数，表示该函数的参数不是对象；

 注意：
 	在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined
 	null == undefined // true
 	null === undefined // false

 再来一个例子：

 	null
 	Q：有张三这个人么？
 	A：有！
 	Q：张三有房子么？
 	A：没有！

 	undefined
 	Q：有张三这个人么？
 	A：有！
 	Q: 张三有多少岁？
 	A: 不知道（没有被告诉）

```



### 说几条写JavaScript的基本规范？

```
 1.不要在同一行声明多个变量。
 2.请使用 ===/!==来比较true/false或者数值
 3.使用对象字面量替代new Array这种形式
 4.不要使用全局函数。
 5.Switch语句必须带有default分支
 6.函数不应该有时候有返回值，有时候没有返回值。
 7.For循环必须使用大括号
 8.If语句必须使用大括号
 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。

```



### Ajax 

```




```




### 异步加载JS的方式有哪些？

```

(1) defer，只支持IE

(2) async：

(3) 创建script，插入到DOM中，加载完毕后callBack

```





### JavaScript 核心概念

### 原型，原型链

```

所有引用类型（Array， Object， Function）都有 __proto__ 属性（隐式原型）
属性值为普通对象

所有函数都有 prototype 属性，属性值为普通对象 （显式原型）

__proto__ 指向构造函数的 prototype

prototype 也有 __proto__ 属性，也指向它的构造函数的 prototype

一直指到 Object.prototype 为止 

因为 Object.prototype.__proto__ = null



Function instanceof Function
true

Object instanceof Object 
true

Object instanceof Function
true

Function instanceof Object
true


```



### this

```




```


### 作用域链，上下文

```


```


### 闭包

```


```



### 继承


```

Object.create
class


function inherit(superType, subType){
    var _prototype  = Object.create(superType.prototype)
    _prototype.constructor = subType
    subType.prototype = _prototype
}



class p1 {
    constructor () {
        this.name = 'p1'
    }
}

class c1 extends p1 {
    construtor(name) {
        super(name)
    }
}

new p1()





function p2 () {
    this.name = 'p2'
    this.play = [1, 2, 3]
}

p2.prototype.say = function () {
    console.log(this)
}

function c2 () {
    p2.call(this)
    this.type = 'c2'
}

// c2.prototype = new p2()
// c2.prototype = p2.prototype
 c2.prototype = Object.create(p2.prototype)
//不这样写，会导致后续修改子类的prototype也修改了父类的prototype

c2.prototype.constructor = c2

c2.prototype.call = function() {
    console.log('call')
}


var s1 = new p2()
var s2 = new c2()

s1.say()
s2.say()



```


### 面向对象


```




new 关键字做了什么

绑定原型链的作用

new 的过程

1. 创建一个临时对象 {}

2. {}.__proto__ = new后面的对象.原型
   {}.属性 = new后面的对象.属性

3. return {}

4. new后面的对象.原型 起名为 new后面的对象.prototype


new后面的对象.prototype 上有个 constructor 属性
指向new后面的对象


```


### 异步

```

不按顺序执行
让js执行不必等待某些事件处理完才继续执行
避免了阻塞



常见异步

setTimeout(() => {}, 0)
setInterval(() => {}, 0)

async await

new Promise((resolve, reject) => {

})

function* gen() {
    yield fn()
}

mutationObserver



异步有两种事件队列

microtask  [当前js执行loop的尾部]

macrotask  [下个js执行loop的首部]

js执行

一行一行执行

sync  [1, 2, 3, 4] 

async [microtask] [macrotask]

所有 sync 执行完
再执行 async 
所有 [microtask] 执行完
再执行 [macrotask] 



MicroTask和macroTask的api范畴

macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering

microtasks: process.nextTick, Promises, Object.observe, MutationObserver






```



[参考0](http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context)  
[参考1](http://www.jianshu.com/p/12b9f73c5a4f#)  
[参考2](http://www.jianshu.com/p/3ed992529cfc)  
[参考3](https://segmentfault.com/a/1190000008866165)  



输出  3 1 5 4  

![001](../Img/async/001.jpg)

输出 start 1 2 end

![003](../Img/async/003.jpg)










### 科里化


```
多参函数变单参函数

fn(1,2,3) => fn(1)(2)(3)





```




### CommonJS规范

```



```


### AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？

```

AMD 规范在这里：https://github.com/amdjs/amdjs-api/wiki/AMD
CMD 规范在这里：https://github.com/seajs/seajs/issues/242
 Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。
 所有依赖某些模块的语句均放置在回调函数中。

  区别：

     1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。
     不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。
     CMD 推崇 as lazy as possible.
     2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：

 // CMD
 define(function(require, exports, module) {
     var a = require('./a')
     a.doSomething()
     // 此处略去 100 行
     var b = require('./b') // 依赖可以就近书写
     b.doSomething()
     // ...
 })

 // AMD 默认推荐
 define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
     a.doSomething()
     // 此处略去 100 行
     b.doSomething()
     // ...
 })

```


### requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）

```

 参考：http://annn.me/how-to-realize-cmd-loader/

```





</x-markdown>
   
    <script src="https://cdn.bootcss.com/marked/0.3.6/marked.min.js"></script>
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../js/main.js"></script>
</body>
</html>