<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Document</title>
     <link rel="stylesheet" href="../style/default.css">
     <link href="https://cdn.bootcss.com/highlight.js/9.11.0/styles/monokai-sublime.min.css" rel="stylesheet">
</head>
<body>
<x-markdown>

# 导航

* [返回Github](https://github.com/LDQ-first/frontend)
* [返回首页](../index.html)


## 杂



### 输入url到页面完成显示的过程

1. DNS 解析
   - 利用本地host文件进行解析
   - DNS缓存
   - 运营商DNS服务器
   - 根域名服务器

2. TCP连接
    - 三次握手

 
```
第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认；
第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，
随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。
第三次握手：客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，
服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手。

```


   
  - HTTPS SSL/TLS握手

 
```

第一次握手：客户端先向服务器发出加密通信的请求，并且提供自己的一些信息(加密方法等)，这被叫做ClientHello请求。
第二次握手：服务器收到客户端请求后，向客户端发出回应，并且提供服务器证书、确认的加密方法等，这叫做SeverHello。
第三次握手：客户端收到服务器回应以后，首先验证服务器证书，如果没问题的话会向服务器发送用于加密的随机数、编码改变通知、客户端握手结束通知。
第四次握手：服务器收到客户端的随机数之后，计算生成本次会话所用的"会话密钥"，然后向客户端发送编码改变通知和服务器握手结束通知。

```
 


3. HTTP请求和响应
    - 请求头  
       - 方法 路径 协议 
       - 各种HTTP头
         缓存
         类型

    - 参数   

    - 响应头   
    - 响应体   内容（静态资源，json数据）




#### 服务端的视角

```

- 负载均衡

请求报文不是直接到服务器的，可能是经过反向代理负载均衡处理过才到达的。
负载均衡有DNS负载均衡、IP负载均衡等多种方式，常用的负载均衡算法有，
轮询，随机，最少链接，源地址散列，加权等方式。

- 处理请求

如果服务端设置了反向代理的话，请求会先经过它，反向代理类似于"中间人"，既可以是客户端，
也可以是服务端，它最大的作用就是帮助服务端更有效率地处理报文，
比如负载均衡、缓存静态内容等。

```
 


4. 浏览器渲染
   - dom树
   - css树
   - 渲染树
   - js
   - 外部资源


5 关闭TCP连接


  - TCP四次挥手

 
```
第一次挥手：客户端发送一个FIN，客户端进入FIN_WAIT_1状态。
第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到seq+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态。
第三次挥手：服务端发送一个FIN，服务端进入LAST_ACK状态。
第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务端，确认序号为收到seq+1，服务端进入CLOSED状态，完成四次挥手。

```


![001](../Img/url/001.png)





### 浏览器渲染过程


**1  解析HTML文件，创建DOM树**

HTML字节流 转换字符流
浏览器进行词法分析，分析成相应的token，再添加到dom树中

从上往下
并逐步引入外部资源
遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）

遇到script标签 

这个时候，浏览器会暂停渲染HTML，将script交给js引擎编译执行。js会创建textNode

![001](../Img/browser/001.jpg)
![001](../Img/browser/002.jpg)



**2  解析CSS **

优先级：浏览器默认设置 < 用户设置 < 外部样式 < 内联样式 < HTML中的style样式

权重：id数 * 100 + 类或伪类数 * 10 + tag名称 * 1

与dom树相结合构成渲染树


**3  布局和绘制，重绘（repaint）和重排（reflow）**

重排：若渲染树的一部分更新，且尺寸变化，就会发生重排

重绘：部分节点需要更新，但不改变其他集合形状。如改变某个元素的颜色，就会发生重绘。 



文档加载完成的事件是DOMContentLoad这个事件是HTML文档解析完成的事件。
而onload事件是HTML里面的外部资源等下载完成的事件。


![001](../Img/webkitflow.png)





### 跨域的方法



- 起因

 
```
由于JavaScript对安全访问因素的考虑，是不允许js跨域调用其他页面的内容

同源策略具体分为以下几类：

不同域名

相同域名不同端口号，如https://www.oschina.net:8000和https://www.oschina.net:8001  
同一个域名不同协议，如http://www.oschina.net/和https://www.oschina.net/  
域名和域名对应的的IP，如http://b.qq.com/和 http://10.198.7.85  
主域和子域，如http://www.oschina.net/和https://test.oschina.net  
子域和子域，如https://test1.oschina.net和https://test2.oschina.net  
```
 


- 解决 

 

1、 jsonp

```

支持 get方法
不支持 post方法

原理：

后端返回数据时封装一层函数  
前端接受时用该函数将数据当成script一样解析
因为script标签不受跨域限制，所以可以跨域

<script>
function jsonpCallBack (res, req) {
  console.log(res, req);
}
</script>
< script type="text/JavaScript" src="http://localhost/test/jsonp.php?callback=jsonpCallBack&data=getJsonpData" >< /script >

```


2、 跨域资源共享（CORS-Cross Origin Resource Sharing）

```

CORS，它是JSONP模式的现代升级版，与JSONP不同的是，CORS除了GET要求方法以外也支持其他的 HTTP要求。

实现

后端添加响应头

Access-Control-Allow-Origin: （允许跨域的域名）[ * 所有域名 ]



浏览器CORS请求分成两种
a、简单请求
b、协商模型/预检请求（Preflighted Request），即非简单请求

如何区分请求具体属于哪一种呢，下面我总结了几点：
1) 请求方式

GET
HEAD
POST
2）HTTP的头信息子段

Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain，
其中'text/plain'默认支持，其他两种则需要预检请求和服务器协商。

满足以上两大点的即为简单请求，否则为非简单请求。
具体请求处理的不同，大家可以去查阅下MDN HTTP访问控制(CORS) ，那里有详细的解析及用法。

```


3、document.domain+iframe（适用于主域名相同的情况）

```

从上面的同源策略我们可以知道，浏览器这边是认为主域和子域、子域和子域，它们属于不同的域，
那么我们如果需要让主域和子域之间可以进行通信，需要做的就是通过修改document.domain，把它们改成相同的domain

在域名为 http://server.example.com 中的 a.html

document.domain = 'example.com' 
const $iframe = document.createElement('iframe') 
$iframe.src = 'server.child.example.com/b.html' 
$iframe.style.display = 'none' 
document.body.appendChild($iframe) 
$iframe.onload = () => {
    const doc = $iframe.contentDocument || $iframe.contentWindow.document 
    //在这里操作doc，也就是操作b.html
    $iframe.onload = null 
}

在域名为 http://server.child.example.com 中的 b.html

document.domain = 'example.com'


这种形式方便归方便，但也有其方便带来的隐患

安全性，当一个站点被攻击后，另一个站点会引起安全漏洞。
若页面中引入多个iframe，要想操作所有iframe，domain需要全部设置成一样的。


```


4、 window.name + iframe

```
window 对象的name属性是一个很特别的属性，它可以在不同页面甚至不同域名加载后依旧存在。使用步骤如下：
step1 - 首先在页面A中利用iframe加载其他域中的页面B
step2 - 在页面B中将需要传递的数据赋给window.name
step3 - iframe加载完成后，页面A中修改iframe地址，
将其变成同一个域下的地址，然后获取iframe中页面B的window.name 属性


示例代码如下：
首先我们在域名为 http://127.0.0.1 下建立好B页面，
在B页面的< script >标签中将需要传递的数据赋给window.name

window.name = '页面B中传递给页面A的数据'

然后我们域名为 http://127.0.0.1:900  的A页面,
这里我们需要做的一件事就是利用iframe加载页面B，并将其域名进行修改，变成和页面A一样的域名。


function proxy (url, callback) {
    var flag = true,
        $iframe = document.createElement('iframe'),
        loadCallBack = function () {
            if (flag) {
                // 这里我们还得在域名为 http://127.0.0.1:9000 建立一个tmp.html文件当做缓存界面
                $iframe.contentWindow.location = 'http://127.0.0.1:9000/tmp.html'
                flag = false
            }
            // 修改localtion后，每次触发onload事件会重置src，相当于重新载入页面，然后继续触发onload。
            // 这里是针对该问题做的处理
            else {
                callback($iframe.contentWindow.name)
                $iframe.contentWindow.close()
                document.body.removeChild($iframe)
                $iframe.src = ''
                $iframe = null
            }
        }

    $iframe.src = url
    $iframe.style.display = 'none'
    // 事件绑定兼容简单处理
    // IE 支持iframe的onload事件，不过是隐形的，需要通过attachEvent来注册
    if ($iframe.attachEvent) {
        $iframe.attachEvent('onload', loadCallBack)
    }
    else {
        $iframe.onload = loadCallBack
    }

    document.body.appendChild($iframe)
}
proxy('http://127.0.0.1/bop/test.html', function(data){
    console.log(data)
})
```



5、HTML5中的postMessage（适用于两个iframe或两个页面之间）

```

postMessage隶属于html5，但是它支持IE8+和其他浏览器，可以实现同域传递，也能实现跨域传递。
它包括发送消息postMessage和接收消息message功能。

postMessage调用语法如下

otherWindow.postMessage(message, targetOrigin, [transfer])


otherWindow ： 其他窗口的一个引用，比如iframe的contentWindow属性、
执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。

message ： 将要发送到其他 window的数据，类型为string或者object。

targetOrigin ： 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。

transfer (可选) ： 一串和message 同时传递的 Transferable 对象。



接收消息message 的属性有:

data ：从其他 window 中传递过来的数据。
origin ：调用 postMessage 时消息发送方窗口的 origin 。
source ：对发送消息的窗口对象的引用。

示例如下：域名 http://127.0.0.1:9000 页面A
通过iframe嵌入了 http://127.0.0.1 页面B，
接下来页面A将通过postMessage对页面B进行数据传递，页面B将通过message属性接收页面A的数据

```













### 如何在页面上实现一个圆形的可点击区域？


 
 1、map+area或者svg

 2、border-radius

 3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等

 

### audio元素和video元素在ios和andriod中无法自动播放

```
 
//音频，写法一

audio src="music/bg.mp3" autoplay loop controls 你的浏览器还不支持哦 audio


//音频，写法二

    audio controls="controls" 

    source src="music/bg.ogg" type="audio/ogg" source

    source src="music/bg.mp3" type="audio/mpeg" source

    优先播放音乐bg.ogg，不支持在播放bg.mp3

    /audio


//JS绑定自动播放（操作window时，播放音乐）

$(window).one('touchstart', function(){
    music.play();
})


//微信下兼容处理

document.addEventListener("WeixinJSBridgeReady", function () {
    music.play();
}, false);


//小结

1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常

2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间

```
 





### 浏览器内核

``` 

渲染引擎

  - Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]
  - Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
  - Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]
  - Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]


JS引擎
 - Chrome V8

``` 

 

### 请描述一下 cookies，sessionStorage 和 localStorage 的区别？  

```

 - cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
 - cookie 数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
 - sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。


 - 存储大小：
  - cookie数据大小不能超过4k。
  - sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

 - 有期时间：
  - localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
  - sessionStorage  数据在当前浏览器窗口关闭后自动删除。
  - cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭





  
 
```




### iframe有那些缺点？


  - iframe会阻塞主页面的Onload事件；
  - 搜索引擎的检索程序无法解读这种页面，不利于SEO;

  - iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

  - 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
    动态给iframe添加src属性值，这样可以绕开以上两个问题。

 

### 如何实现浏览器内多个标签页之间的通信?

```
localStorage


server Work

```


### webSocket如何兼容低浏览器？

```
  Adobe Flash Socket 、
  ActiveX HTMLFile (IE) 、
  基于 multipart 编码发送 XHR 、
  基于长轮询的 XHR
```
 

### 网页验证码是干嘛的，是为了解决什么安全问题


- 分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水
- 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试


 






</x-markdown>
    <script src="https://cdn.bootcss.com/marked/0.3.6/marked.min.js"></script>
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../js/main.js"></script>
</body>
</html>