<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Document</title>
     <link rel="stylesheet" href="../style/default.css">
     <link href="https://cdn.bootcss.com/highlight.js/9.11.0/styles/monokai-sublime.min.css" rel="stylesheet">
</head>
<body>
<x-markdown>

# 导航

* [返回Github](https://github.com/LDQ-first/frontend)
* [返回首页](../index.html)


## 杂



### 输入url到页面完成显示的过程

1. DNS 解析
   - 利用本地host文件进行解析
   - DNS缓存
   - 运营商DNS服务器
   - 根域名服务器

2. TCP连接
    - 三次握手

 
```
第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认；
第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，
随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。
第三次握手：客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，
服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手。

```


   
  - HTTPS SSL/TLS握手

 
```

第一次握手：客户端先向服务器发出加密通信的请求，并且提供自己的一些信息(加密方法等)，这被叫做ClientHello请求。
第二次握手：服务器收到客户端请求后，向客户端发出回应，并且提供服务器证书、确认的加密方法等，这叫做SeverHello。
第三次握手：客户端收到服务器回应以后，首先验证服务器证书，如果没问题的话会向服务器发送用于加密的随机数、编码改变通知、客户端握手结束通知。
第四次握手：服务器收到客户端的随机数之后，计算生成本次会话所用的"会话密钥"，然后向客户端发送编码改变通知和服务器握手结束通知。

```
 


3. HTTP请求和响应
    - 请求头  
       - 方法 路径 协议 
       - 各种HTTP头
         缓存
         类型

    - 参数   

    - 响应头   
    - 响应体   内容（静态资源，json数据）




#### 服务端的视角

```

- 负载均衡

请求报文不是直接到服务器的，可能是经过反向代理负载均衡处理过才到达的。
负载均衡有DNS负载均衡、IP负载均衡等多种方式，常用的负载均衡算法有，
轮询，随机，最少链接，源地址散列，加权等方式。

- 处理请求

如果服务端设置了反向代理的话，请求会先经过它，反向代理类似于"中间人"，既可以是客户端，
也可以是服务端，它最大的作用就是帮助服务端更有效率地处理报文，
比如负载均衡、缓存静态内容等。

```
 


4. 浏览器渲染
   - dom树
   - css树
   - 渲染树
   - js
   - 外部资源


5 关闭TCP连接


  - TCP四次挥手

 
```
第一次挥手：客户端发送一个FIN，客户端进入FIN_WAIT_1状态。
第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到seq+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态。
第三次挥手：服务端发送一个FIN，服务端进入LAST_ACK状态。
第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务端，确认序号为收到seq+1，服务端进入CLOSED状态，完成四次挥手。

```


![001](../Img/url/001.png)





### 浏览器渲染过程


**1  解析HTML文件，创建DOM树**

HTML字节流 转换字符流
浏览器进行词法分析，分析成相应的token，再添加到dom树中

从上往下
并逐步引入外部资源
遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）

遇到script标签 

这个时候，浏览器会暂停渲染HTML，将script交给js引擎编译执行。js会创建textNode

![001](../Img/browser/001.jpg)
![001](../Img/browser/002.jpg)



**2  解析CSS **

优先级：浏览器默认设置 < 用户设置 < 外部样式 < 内联样式 < HTML中的style样式

权重：id数 * 100 + 类或伪类数 * 10 + tag名称 * 1

与dom树相结合构成渲染树


**3  布局和绘制，重绘（repaint）和重排（reflow）**

重排：若渲染树的一部分更新，且尺寸变化，就会发生重排

重绘：部分节点需要更新，但不改变其他集合形状。如改变某个元素的颜色，就会发生重绘。 



文档加载完成的事件是DOMContentLoad这个事件是HTML文档解析完成的事件。
而onload事件是HTML里面的外部资源等下载完成的事件。


![001](../Img/webkitflow.png)





### 跨域的方法



- 起因

 
```
由于JavaScript对安全访问因素的考虑，是不允许js跨域调用其他页面的内容

同源策略具体分为以下几类：

不同域名

相同域名不同端口号，如https://www.oschina.net:8000和https://www.oschina.net:8001  
同一个域名不同协议，如http://www.oschina.net/和https://www.oschina.net/  
域名和域名对应的的IP，如http://b.qq.com/和 http://10.198.7.85  
主域和子域，如http://www.oschina.net/和https://test.oschina.net  
子域和子域，如https://test1.oschina.net和https://test2.oschina.net  
```
 


- 解决 

 

1、 jsonp

```

支持 get方法
不支持 post方法

原理：

后端返回数据时封装一层函数  
前端接受时用该函数将数据当成script一样解析
因为script标签不受跨域限制，所以可以跨域

<script>
function jsonpCallBack (res, req) {
  console.log(res, req);
}
</script>
< script type="text/JavaScript" src="http://localhost/test/jsonp.php?callback=jsonpCallBack&data=getJsonpData" >< /script >

```


2、 跨域资源共享（CORS-Cross Origin Resource Sharing）

```

CORS，它是JSONP模式的现代升级版，与JSONP不同的是，CORS除了GET要求方法以外也支持其他的 HTTP要求。

实现

后端添加响应头

Access-Control-Allow-Origin: （允许跨域的域名）[ * 所有域名 ]



浏览器CORS请求分成两种
a、简单请求
b、协商模型/预检请求（Preflighted Request），即非简单请求

如何区分请求具体属于哪一种呢，下面我总结了几点：
1) 请求方式

GET
HEAD
POST
2）HTTP的头信息子段

Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain，
其中'text/plain'默认支持，其他两种则需要预检请求和服务器协商。

满足以上两大点的即为简单请求，否则为非简单请求。
具体请求处理的不同，大家可以去查阅下MDN HTTP访问控制(CORS) ，那里有详细的解析及用法。

```


3、document.domain+iframe（适用于主域名相同的情况）

```

从上面的同源策略我们可以知道，浏览器这边是认为主域和子域、子域和子域，它们属于不同的域，
那么我们如果需要让主域和子域之间可以进行通信，需要做的就是通过修改document.domain，把它们改成相同的domain

在域名为 http://server.example.com 中的 a.html

document.domain = 'example.com' 
const $iframe = document.createElement('iframe') 
$iframe.src = 'server.child.example.com/b.html' 
$iframe.style.display = 'none' 
document.body.appendChild($iframe) 
$iframe.onload = () => {
    const doc = $iframe.contentDocument || $iframe.contentWindow.document 
    //在这里操作doc，也就是操作b.html
    $iframe.onload = null 
}

在域名为 http://server.child.example.com 中的 b.html

document.domain = 'example.com'


这种形式方便归方便，但也有其方便带来的隐患

安全性，当一个站点被攻击后，另一个站点会引起安全漏洞。
若页面中引入多个iframe，要想操作所有iframe，domain需要全部设置成一样的。


```


4、 window.name + iframe

```
window 对象的name属性是一个很特别的属性，它可以在不同页面甚至不同域名加载后依旧存在。使用步骤如下：
step1 - 首先在页面A中利用iframe加载其他域中的页面B
step2 - 在页面B中将需要传递的数据赋给window.name
step3 - iframe加载完成后，页面A中修改iframe地址，
将其变成同一个域下的地址，然后获取iframe中页面B的window.name 属性


示例代码如下：
首先我们在域名为 http://127.0.0.1 下建立好B页面，
在B页面的< script >标签中将需要传递的数据赋给window.name

window.name = '页面B中传递给页面A的数据'

然后我们域名为 http://127.0.0.1:900  的A页面,
这里我们需要做的一件事就是利用iframe加载页面B，并将其域名进行修改，变成和页面A一样的域名。


function proxy (url, callback) {
    var flag = true,
        $iframe = document.createElement('iframe'),
        loadCallBack = function () {
            if (flag) {
                // 这里我们还得在域名为 http://127.0.0.1:9000 建立一个tmp.html文件当做缓存界面
                $iframe.contentWindow.location = 'http://127.0.0.1:9000/tmp.html'
                flag = false
            }
            // 修改localtion后，每次触发onload事件会重置src，相当于重新载入页面，然后继续触发onload。
            // 这里是针对该问题做的处理
            else {
                callback($iframe.contentWindow.name)
                $iframe.contentWindow.close()
                document.body.removeChild($iframe)
                $iframe.src = ''
                $iframe = null
            }
        }

    $iframe.src = url
    $iframe.style.display = 'none'
    // 事件绑定兼容简单处理
    // IE 支持iframe的onload事件，不过是隐形的，需要通过attachEvent来注册
    if ($iframe.attachEvent) {
        $iframe.attachEvent('onload', loadCallBack)
    }
    else {
        $iframe.onload = loadCallBack
    }

    document.body.appendChild($iframe)
}
proxy('http://127.0.0.1/bop/test.html', function(data){
    console.log(data)
})
```



5、HTML5中的postMessage（适用于两个iframe或两个页面之间）

```

postMessage隶属于html5，但是它支持IE8+和其他浏览器，可以实现同域传递，也能实现跨域传递。
它包括发送消息postMessage和接收消息message功能。

postMessage调用语法如下

otherWindow.postMessage(message, targetOrigin, [transfer])


otherWindow ： 其他窗口的一个引用，比如iframe的contentWindow属性、
执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。

message ： 将要发送到其他 window的数据，类型为string或者object。

targetOrigin ： 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。

transfer (可选) ： 一串和message 同时传递的 Transferable 对象。



接收消息message 的属性有:

data ：从其他 window 中传递过来的数据。
origin ：调用 postMessage 时消息发送方窗口的 origin 。
source ：对发送消息的窗口对象的引用。

示例如下：域名 http://127.0.0.1:9000 页面A
通过iframe嵌入了 http://127.0.0.1 页面B，
接下来页面A将通过postMessage对页面B进行数据传递，页面B将通过message属性接收页面A的数据

```













### 如何在页面上实现一个圆形的可点击区域？


 
 1、map+area或者svg

 2、border-radius

 3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等

 

### audio元素和video元素在ios和andriod中无法自动播放

```
 
//音频，写法一

audio src="music/bg.mp3" autoplay loop controls 你的浏览器还不支持哦 audio


//音频，写法二

    audio controls="controls" 

    source src="music/bg.ogg" type="audio/ogg" source

    source src="music/bg.mp3" type="audio/mpeg" source

    优先播放音乐bg.ogg，不支持在播放bg.mp3

    /audio


//JS绑定自动播放（操作window时，播放音乐）

$(window).one('touchstart', function(){
    music.play();
})


//微信下兼容处理

document.addEventListener("WeixinJSBridgeReady", function () {
    music.play();
}, false);


//小结

1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常

2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间

```
 





### 浏览器内核

``` 

渲染引擎

  - Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]
  - Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
  - Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]
  - Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]


JS引擎
 - Chrome V8

``` 

 

### 请描述一下 cookies，sessionStorage 和 localStorage 的区别？  

```

 - cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
 - cookie 数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
 - sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。


 - 存储大小：
  - cookie数据大小不能超过4k。
  - sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

 - 有期时间：
  - localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
  - sessionStorage  数据在当前浏览器窗口关闭后自动删除。
  - cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭









 
```


### cookie、session、localStorage分别是什么？有什么作用？


```

cookie

cookie是存储在浏览器上的一小段数据，
用来记录某些当页面关闭或者刷新后仍然需要记录的信息。
在控制台用 「document.cookie」查看你当前正在浏览的网站的cookie。

cookie可以使用 js 在浏览器直接设置（用于记录不敏感信息，如用户名）,
 也可以在服务端通使用 HTTP 协议规定的 set-cookie 来让浏览器种下cookie，
 这是最常见的做法。
 （打开一个网站，清除全部cookie，然后刷新页面，在network的Response headers试试找一找set-cookie吧）

每次网络请求 Request headers 中都会带上cookie。所以如果 cookie 太多太大对传输效率会有影响。

一般浏览器存储cookie 最大容量为4k，所以大量数据不要存到cookie。

设置cookie时的参数：
path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。
      expires 和 maxAge：告诉浏览器 cookie 时候过期，maxAge 是 cookie 多久后过期的相对时间。
      不设置这两个选项时会产生 session cookie，session cookie 是 transient 的，
      当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。
secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，
        在 HTTPS 中才有效
httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。
         一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。


Cookie 一般有两个作用。

第一个作用是识别用户身份。
第二个作用是记录历史。



session

当一个用户打开淘宝登录后，刷新浏览器仍然展示登录状态。
服务器如何分辨这次发起请求的用户是刚才登录过的用户呢？
这里就使用了session保存状态。
用户在输入用户名密码提交给服务端，
服务端验证通过后会创建一个session用于记录用户的相关信息，
这个 session 可保存在服务器内存中，也可保存在数据库中。



创建session后，会把关联的session_id 通过setCookie 
添加到http响应头部中。
浏览器在加载页面时发现响应头部有 set-cookie字段，
就把这个cookie 种到浏览器指定域名下。




当下次刷新页面时，发送的请求会带上这条cookie，
 服务端在接收到后根据这个session_id来识别用户。
cookie 是存储在浏览器里的一小段「数据」，
而session是一种让服务器能识别某个用户的「机制」，
session 在实现的过程中需要使用cookie。 
二者不是同一维度的东西。




localStorage


localStorage HTML5本地存储web storage特性的API之一，
用于将大量数据（最大5M）保存在浏览器中，
保存后数据永远存在不会失效过期，除非用 js手动清除。

不参与网络传输。
一般用于性能优化，可以保存图片、js、css、html 模板、大量数据。



```



### 如何在不刷新页面的情况下改变URL?

```

整理下需求：

点击分页页码可实现无刷新页面加载

同时 URL 在数据加载后会发生变化展示对应页码

刷新页面（带页码参数）会定位到当前页码

当点击返回时可会到上个页面



效果如 http://book.jirengu.com/jirengu-inc/js-works/projects/sinanews/index.html?page=1 所示。

对于第1条，我们可以使用 ajax 动态获取对应页码的数据。

对于第2条，我们可以使用 html5的 api「history.pushState」，用于改变 URL。

对于第3条，我们可以根据 URL 中页码参数获取对应页码的数据再做展示。

对于第4条，可以使用 「window.onpopstate」来监听返回事件


那history.pushState如何使用呢？比如当用户点击页码按钮时，
可使用 ajax 获取对应页码的数据，拼装 DOM 放到页面上，
然后调用下面的 setUrl 方法实现浏览器 URL 的更新。

function setUrl(page){
    var url = location.pathname + '?page=' +  page
    history.pushState({url: url, title: document.title}, document.title, url)
}

history.pushState() 带有三个参数：
一个状态对象，一个标题（现在被忽略了），以及一个可选的URL地址。


state object — 状态对象是一个由 pushState()方法创建的与历史纪录相关的JS对象。



title — 火狐浏览器现在已经忽略此参数，将来也许可能被使用。
考虑到将来有可能的改变，传递一个空字符串是安全的做法。
当然，你可以传递一个短标题给你要转变成的状态。


URL — 这个参数提供了新历史纪录的地址。请注意，
浏览器在调用pushState()方法后不会去加载这个URL，
但有可能在之后会这样做，比如用户重启浏览器之后。
新的URL可以是绝对地址，也可以是相对地址。
新URL必须和当前URL在同一个源下。






```







### iframe有那些缺点？


  - iframe会阻塞主页面的Onload事件；
  - 搜索引擎的检索程序无法解读这种页面，不利于SEO;

  - iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

  - 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
    动态给iframe添加src属性值，这样可以绕开以上两个问题。

 

### 如何实现浏览器内多个标签页之间的通信?

```
localStorage


server Work

```


### webSocket如何兼容低浏览器？

```
  Adobe Flash Socket 、
  ActiveX HTMLFile (IE) 、
  基于 multipart 编码发送 XHR 、
  基于长轮询的 XHR
```
 

### 网页验证码是干嘛的，是为了解决什么安全问题


- 分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水
- 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试


 






</x-markdown>
    <script src="https://cdn.bootcss.com/marked/0.3.6/marked.min.js"></script>
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../js/main.js"></script>
</body>
</html>