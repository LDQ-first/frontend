<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../style/default.css">
    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
</head>
<body>
<x-markdown>

# 导航

* [返回Github](https://github.com/LDQ-first/frontend)
* [返回首页](../index.html)



## JavaScript


### 介绍js的基本数据类型。

```
  Undefined、Null、Boolean、Number、String、
  ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )

```

### 复杂数据类型

```
Array, Object, Function

```

### 介绍js有哪些内置对象？

```
 Object 是 JavaScript 中所有对象的父对象

 数据封装类对象：Object、Array、Boolean、Number 和 String
 其他对象：Function、Arguments、Math、Date、RegExp、Error
```


### typeof && instanceof

```
typeof

typeof 0
"number"

typeof '0'
"string"

typeof undefined
"undefined"

typeof null
"object"

typeof {}
"object"

typeof []
"object"

typeof function () {}
"function"

typeof Symbol()
"symbol"




instanceof 


new Number() instanceof Number
true

new String() instanceof String
true

new Function() instanceof Function 
true

new Date() instanceof Date 
true

new RegExp() instanceof RegExp 
true

new Error() instanceof Error 
true

new Object() instanceof Object 
true

new Array () instanceof Array 
true

new Boolean() instanceof Boolean
true




Function instanceof Function
true

Object instanceof Object 
true

Object instanceof Function
true

Function instanceof Object
true

Array instanceof Array 
false


```


![001](../Img/type/001.jpg)


### 类型识别

```
typeof
   typeof可以识别标准类型null除外
   typeof不能识别具体的对象类型除了function外
 
 Object.prototype.toString
   Object.prototype.toString可以识别出标准类型以及所有的内置对象类型
   Object.prototype.toString不能识别自定义对象

 constructor
   constructor可以识别标准类型（undefined、null除外因为没有构造器）
   constructor可以识别内置对象类型
   constructor可以识别自定义对象类型

 instanceof
    instanceof 可以判别内置对象
    instanceof 不能判别基本类型
    instanceof 可以判别自定义对象
```




### JavaScript有几种类型的值？，你能画一下他们的内存图吗？

```

 栈：原始数据类型（Undefined，Null，Boolean，Number、String）
 堆：引用数据类型（对象、数组和函数）

 两种类型的区别是：存储位置不同；
 原始数据类型直接存储在栈(stack)中的简单数据段，
 占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；

 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。
 如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，
 该指针指向堆中该实体的起始地址。
 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体

```

![001](../Img/var/001.gif)



###  document.write 作用

```

当你打开一个页面，浏览器会

1 调用 document.open() 打开文档
2 document.write(...) 将下载到的网页内容写入文档
3 所有内容写完了，就调用 document.close()
4 触发 dom ready 事件（DOMContentReady)

所以你如果在第3步之前 document.write(1) 那么你就直接追加内容到当前位置，
如果你在第3步之后 document.write()，那么由于 document 已经 close 了，
所以必须重新 document.open() 来打开文档，这一打开，内容就被清空了。


```


### 为什么 0.1 + 0.2 结果为 0.30000000000000004

```

0.1 + 0.2
0.30000000000000004


需要有以下基础知识：

计算机将所有数据以二进制的形式存储
计算机用有限的大小来存储数据（因为现实生活中不存在无限大的内存或硬盘）

好的，然后结合我们的问题来看。


计算机如何存储 0.1 和 0.2？

十进制的 0.1 转为二进制，得到一个无限循环小数：0.00011…。

也就是说，二进制无法「用有限的位数」来表示 0.1。对于 0.2 也是一样的，不赘述。
二进制能「用有限的位数」表示的有：0.5、0.25、0.125 等。

但是计算机只能用有限的位数来存一个数，所以最终，计算机存的数是一个近似于 0.1 的小数。

确切的二进制值是0-01111111011-1001100110011001100110011001100110011001100110011010，
对应的十进制值是0.10000000000000000555...。


这是计算机能表示的最接近 0.1 的数字（存储一个数字的空间越大则越精确）。
（具体转换过程参考 https://segmentfault.com/a/1190000005022170 ）

所以当我们计算 0.1 + 0.2 时，实际上算的是两个近似值相加，得到的值当然也是近似等于 0.3。

总结

问题的根源是十进制小数转为二进制小数的过程中，会损失精度
你在写代码的过程中，遇到小数都要小心，比如下面的代码会造成死循环

var i = 0.1
while(i!=1){
    console.log(i)
    i += 0.1
}

因为 i 加 9 次 0.1，得到的值是 1 的近似值，并不是 1。
你应该对计算机存储方式有一定的了解。


```



![进制](../Img/二进制/001.png)






### null，undefined 的区别？

```

 null 		表示一个对象是“没有值”的值，也就是值为“空”；
 undefined 	表示一个变量声明了没有初始化(赋值)；

 undefined不是一个有效的JSON，而null是
 undefined的类型(typeof)是undefined
 null的类型(typeof)是object


 Javascript将未赋值的变量默认值设为undefined；
 Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。

 typeof undefined
 	//"undefined"
 	undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；
 	例如变量被声明了，但没有赋值时，就等于undefined

 typeof null
 	//"object"
 	null : 是一个对象(空对象, 没有任何属性和方法)；
 	例如作为函数的参数，表示该函数的参数不是对象；

 注意：
 	在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined
 	null == undefined // true
 	null === undefined // false

 再来一个例子：

 	null
 	Q：有张三这个人么？
 	A：有！
 	Q：张三有房子么？
 	A：没有！

 	undefined
 	Q：有张三这个人么？
 	A：有！
 	Q: 张三有多少岁？
 	A: 不知道（没有被告诉）

```



### 说几条写JavaScript的基本规范？

```
 1.不要在同一行声明多个变量。
 2.请使用 ===/!==来比较true/false或者数值
 3.使用对象字面量替代new Array这种形式
 4.不要使用全局函数。
 5.Switch语句必须带有default分支
 6.函数不应该有时候有返回值，有时候没有返回值。
 7.For循环必须使用大括号
 8.If语句必须使用大括号
 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。

```



### Ajax 

```

Ajax的优点

1. 无刷新更新数据。

2. 异步与服务器通信。

3. 前端和后端负载平衡。

4. 基于标准被广泛支持。

5. 界面与应用分离。


Ajax缺点

1. AjAX干掉了Back和加入收藏书签功能，即对浏览器机制的破坏。

2. AJAX的安全问题。
诸如跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等等

3. 因为网络延迟需要给用户提供必要提示



readyState状态值意义： 

0：请求没有发出（在调用 open() 之前）。 
1：请求已经建立但还没有发出（调用 send() 之前）。 
2：请求已经发出正在处理之中（这里通常可以从响应得到内容头部）。 
3：请求已经处理，响应中通常有部分数据可用，但是服务器还没有完成响应。 
4：响应已完成，可以访问服务器响应并使用它。




封装原生Ajax

const name = 'name'

ajax({
    url: 'http://getData',
    type: 'get',
    data: {
        name: name
    },
    success: (name) => {
        dealWithName(name)
    },
    error: () => {
        err()
    }
})

const dealWithName = (name) => {
    console.log(name)
}

const err = () => {
    console.log('err')
}


const ajax = (obj) => {
    const xhr = new XMLHttpRequest()
    let dataStr = ''
    for(let key in obj.data) {
        dataStr += `${key}=${obj.data[key]}&` 
    }
    dataStr = dataStr.substr(0, dataStr.length - 1)

    xhr.onreadystatechange = () => {
        if(xhr.readyState === 4 && xhr.status === 200) {
            const resContent =  JSON.parse(xhr.responseText)
            obj.success(resContent)
        }
        if(xhr.readyState === 4 && xhr.status === 404) {
            const resContent =  JSON.parse(xhr.responseText)
            obj.error()
        } 
    } 

    if(obj.type.toLowerCase() === 'get') {
        xhr.open(obj.type, `${obj.url}?${dataStr}`, true)
        xhr.send()
    }

    if(obj.type.toLowerCase() === 'post') {
        xhr.open(obj.type, obj.url, true)
        xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded")
        xhr.send(dataStr)
    }
}




promise式封装

fetch({
    url: 'http://getData',
    type: 'get',
    data: {
        name: name
    }
}).then(res => {
    console.log(res)
}).catch(err => {
    console.log(err)
}) 



const fetch = ( obj ) => {
    return new Promise((resolve, reject) => {
        let dataStr = ''
        for(let key in obj.data) {
            dataStr += `${key}=${obj.data[key]}&` 
        }
        dataStr = dataStr.substr(0, dataStr.length - 1)

        if(obj.type.toLowerCase() === 'post') {
            xhr.open(obj.type, obj.url, true)
            xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded")
            xhr.send(obj.data)
        } else if(obj.type.toLowerCase() === 'get') {
            xhr.open(obj.type, `${obj.url}?${dataStr}`, true)
            xhr.send()
        }
        
        xhr.onload = () => {
            resolve(JSON.parse(xhr.responseText))
        }
        xhr.error = () => {
            reject()
        }
    })
    
}




```


### Fetch

```

Fetch 是浏览器提供的原生 AJAX 接口。
使用 window.fetch 函数可以代替以前的 $.ajax、$.get 和 $.post。


fetch('/').then((response) => {
    response.text().then((text) => {
        console.log(text)
    })
})


Fetch API 就是浏览器提供的用来代替 jQuery.ajax 的工具



Fetch API 提供的一组对象

window.fetch 函数只是 Fetch API 提供的众多接口中的一个，还有很多有用的对象：

window.Headers

window.Response

window.Request

……


Fetch API 的特点

基于 Promise（如果你没有学过 Promise，强烈建议你学一学）
不需要依赖第三方库，就可以优雅地使用 AJAX

Fetch API 的问题
使用 fetch 无法取消一个请求。
这是因为 Fetch API 基于 Promise，
而 Promise 无法做到这一点。
不过相信很快就会有对策。





兼容性

有的浏览器没有 Fetch API，没有关系，只要引入一个 polyfill 就可以了：

GitHub - github/fetch: A window.fetch JavaScript polyfill.

http://link.zhihu.com/?target=https%3A//github.com/github/fetch





```




### 异步加载JS的方式有哪些？

```

(1) defer，只支持IE

(2) async：

(3) 创建script，插入到DOM中，加载完毕后callBack

```


### 什么是立即执行函数？有什么作用？

```

立即执行函数就是

1 声明一个匿名函数
2 马上调用这个匿名函数

作用：创建一个独立的作用域



那么为什么还要用另一对括号把匿名函数包起来呢？

其实是为了兼容 JS 的语法。

如果我们不加另一对括号，直接写成

function(){alert('我是匿名函数')}()
浏览器会报语法错误。想要通过浏览器的语法检查，必须加点小东西，比如下面几种

(function(){alert('我是匿名函数')} ()) // 用括号把整个表达式包起来
(function(){alert('我是匿名函数')}) () //用括号把函数包起来
!function(){alert('我是匿名函数')}() // 求反，我们不在意值是多少，只想通过语法检查。
+function(){alert('我是匿名函数')}()
-function(){alert('我是匿名函数')}()
~function(){alert('我是匿名函数')}()
void function(){alert('我是匿名函数')}()
new function(){alert('我是匿名函数')}()





var liList = ul.getElementsByTagName('li')
for(var i=0; i<6; i++){
  liList[i].onclick = function(){
    console.log(i) // 为什么 console.log 出来的总是 6，而不是 0、1、2、3、4、5
  }
}

为什么 alert 的总是 6 呢，因为 i 是贯穿整个作用域的，而不是给每个 li 分配了一个 i


var liList = ul.getElementsByTagName('li')
for(var i=0; i<6; i++){
    (function(i) {
        liList[i].onclick = function(){
            console.log(i) 
        }
    })(i) 
}







```




### JavaScript 核心概念

### 原型，原型链

```

所有引用类型（Array， Object， Function）都有 __proto__ 属性（隐式原型）
属性值为普通对象

所有函数都有 prototype 属性，属性值为普通对象 （显式原型）

__proto__ 指向构造函数的 prototype

prototype 也有 __proto__ 属性，也指向它的构造函数的 prototype

一直指到 Object.prototype 为止 

因为 Object.prototype.__proto__ = null



Function instanceof Function
true

Object instanceof Object 
true

Object instanceof Function
true

Function instanceof Object
true


```



### this

```




```


### 作用域链，上下文

```


```


### 闭包

```





```



### 继承


```

Object.create
class



class p1 {
    constructor () {
        this.name = 'p1'
    }
}

class c1 extends p1 {
    construtor(name) {
        super(name)
    }
}

new p1()





function p2 () {
    this.name = 'p2'
    this.play = [1, 2, 3]
}

p2.prototype.say = function () {
    console.log(this)
}

function c2 () {
    p2.call(this)
    this.type = 'c2'
}

// c2.prototype = new p2()
// c2.prototype = p2.prototype
 c2.prototype = Object.create(p2.prototype)
//不这样写，会导致后续修改子类的prototype也修改了父类的prototype

c2.prototype.constructor = c2

c2.prototype.call = function() {
    console.log('call')
}


var s1 = new p2()
var s2 = new c2()

s1.say()
s2.say()



```


### 面向对象


```




new 关键字做了什么

绑定原型链的作用

new 的过程

1. 创建一个临时对象 {}

2. {}.__proto__ = new后面的对象.原型
   {}.属性 = new后面的对象.属性

3. return {}

4. new后面的对象.原型 起名为 new后面的对象.prototype


new后面的对象.prototype 上有个 constructor 属性
指向new后面的对象



设计模式




```


### 异步

```

不按顺序执行
让js执行不必等待某些事件处理完才继续执行
避免了阻塞



常见异步

setTimeout(() => {}, 0)
setInterval(() => {}, 0)

async await

new Promise((resolve, reject) => {

})

function* gen() {
    yield fn()
}


generator yield

a generator is a special routine that can be used to control the iteration behaviour of a loop. 
-- 维基百科


迭代器

co => promise 处理generator



mutationObserver


rxjs





死循环

var t = true;

window.setTimeout(function (){
    t = false;
},1000);

while (t){}

alert('end');






异步有两种事件队列

microtask  [当前js执行loop的尾部]

macrotask  [下个js执行loop的首部]

js执行

一行一行执行

sync  [1, 2, 3, 4] 

async [microtask] [macrotask]

所有 sync 执行完
再执行 async 
所有 [microtask] 执行完
再执行 [macrotask] 



MicroTask和macroTask的api范畴

macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering

microtasks: process.nextTick, Promises, Object.observe, MutationObserver



async + await ==> generator + 自动执行器 ==> Promise + 语法转换 



MutationObserver
变化观察者

MutationObserver给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.
该API设计用来替换掉在DOM3事件


// Firefox和Chrome早期版本中带有前缀
var MutationObserver = window.MutationObserver 
|| window.WebKitMutationObserver 
|| window.MozMutationObserver

// 选择目标节点
var target = document.querySelector('#some-id');
 
// 创建观察者对象
var observer = new MutationObserver(function(mutations) {
  mutations.forEach(function(mutation) {
    console.log(mutation.type);
  });    
});
 
// 配置观察选项:
var config = { 
    attributes: true, 
    childList: true, 
    characterData: true 
}
 
// 传入目标节点和观察选项
observer.observe(target, config);
 
// 随后,你还可以停止观察
observer.disconnect();










```



[参考0](http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context)  
[参考1](http://www.jianshu.com/p/12b9f73c5a4f#)  
[参考2](http://www.jianshu.com/p/3ed992529cfc)  
[参考3](https://segmentfault.com/a/1190000008866165)  
[参考4]( https://en.wikipedia.org/wiki/Generator_ )  (computer_programming)  
[参考5](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)  
[参考6](https://www.zhihu.com/question/55364497)  




输出  3 1 5 4  

![001](../Img/async/001.jpg)

输出 start 1 2 end

![003](../Img/async/003.jpg)


输出   
y == undefined  
z == undefined  

![006](../Img/async/006.jpg)

输出  
y == 1  
z == 2  

![008](../Img/async/008.jpg)


输出  
task0  
task1  
0秒  
1秒  
2秒 


![010](../Img/async/010.jpg)





### 科里化


```
多参函数变单参函数

fn(1,2,3) => fn(1)(2)(3)





```




### CommonJS规范

```



```


### AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？

```

AMD 规范在这里：https://github.com/amdjs/amdjs-api/wiki/AMD
CMD 规范在这里：https://github.com/seajs/seajs/issues/242
 Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。
 所有依赖某些模块的语句均放置在回调函数中。

  区别：

     1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。
     不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。
     CMD 推崇 as lazy as possible.
     2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：

 // CMD
 define(function(require, exports, module) {
     var a = require('./a')
     a.doSomething()
     // 此处略去 100 行
     var b = require('./b') // 依赖可以就近书写
     b.doSomething()
     // ...
 })

 // AMD 默认推荐
 define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
     a.doSomething()
     // 此处略去 100 行
     b.doSomething()
     // ...
 })

```


### requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）

```

 参考：http://annn.me/how-to-realize-cmd-loader/

```





</x-markdown>
   
    <script src="https://cdn.bootcss.com/marked/0.3.6/marked.min.js"></script>
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../js/main.js"></script>
</body>
</html>