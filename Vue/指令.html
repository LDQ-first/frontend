<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../style/default.css">
    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
</head>
<body>
<x-markdown>

# 导航

* [返回Github](https://github.com/LDQ-first/frontend)
* [返回首页](../index.html)



## vue 指令



```

v-for 循环


显示

if 
v-if v-else-if v-else

v-show


绑定 DOM 属性
v-bind 缩写 :


事件监听
v-on 缩写 @


双向数据绑定
v-model

v-bind + v-on 相当于 v-model 

但有利于了解数据在什么时候被谁怎么改变的




innerText
v-text



innerHTML
v-html

有被XSS攻击的风险
只在可信内容上使用 v-html，永不用在用户提交的内容上



跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。
v-pre



这个指令保持在元素上直到关联实例结束编译。
和 CSS 规则如 [v-cloak] { display: none } 
一起用时，这个指令可以隐藏未编译的 Mustache 标签
直到实例准备完毕。
v-cloak




只渲染元素和组件一次。随后的重新渲染，
元素/组件及其所有的子节点将被视为静态内容并跳过。
这可以用于优化更新性能。
 v-once





```





### 自定义指令


```

Vue.directive(指令名称, (e) => {
  e =》 指令绑定的dom元素
  一系列操作
})

在目标元素上使用
v-指令名称





import Vue from 'vue'
import App from './App'
import hljs from 'highlight.js'
import 'highlight.js/styles/atom-one-dark.css'


Vue.config.productionTip = false

Vue.directive('hljs', (e) => {
  const codes = e.querySelectorAll('pre code')
  codes.forEach(code => {
    hljs.highlightBlock(code)
  })
})




new Vue({
  el: '#app',
  template: '<App/>',
  components: { App }
})




<div class="code" v-hljs>
    <pre><code>{{html}}</code></pre>
</div>





```















</x-markdown>
    <script src="https://cdn.bootcss.com/marked/0.3.6/marked.min.js"></script>
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../js/main.js"></script>
</body>
</html>