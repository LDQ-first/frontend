<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../../style/default.css">
    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
</head>
<body>
<x-markdown>

# 导航

* [返回Github](https://github.com/LDQ-first/frontend)
* [返回首页](../../index.html)



## 题目

### 答案 查看源代码

- 控制台查看结果

- 部分题目由于题目的特殊性而只提供伪代码答案

```

1. 细心 基础api


// 尽可能全面正确的解析一个任意url的所有参数为Object。
var url = 'http://www.domain.com/?user=anonymous&id=123&city=%E5%8C%97%E4%BA%AC&id=456&id=678&enabled';

/**
结果：
{
   user: 'anonymous',
   id: [123, 456], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型
   city: '北京', // 中文
   enabled: true, // 未指定值的 key 约定值为 true
}
*/





2. 实现一个最简单的模板引擎
render('我是{{name}}，年龄{{age}}，性别{{sex}}',{
	name:'姓名',
	age:18
})

// 结果： 我是姓名，年龄18，性别undefined。




3. 将一个任意长的数字变成逗号分割的格式
	// 1234.56 => "1,234.56" , 123456789 => "123,456,789"
    parseToMoney(1234.56) // return "1,234.56"





4. 请用js计算出我到底有多少钱（输出Number类型数字，代码尽量简洁，考虑通用情况）
var string = "我的账户余额：2,235,467.20";
console.log(?);





5. 有一个全局变量 a，有一个全局函数 b，实现一个方法bindData，执行后，a的任何赋值都会触发b的执行。
const obj = {
    a: 1
}
function b(){
    console.log('a的值发生改变')
}
bindData(obj, b)
obj.a = 2; // 此时输出 a的值发生改变





6. 实现一个 js 的 class ，名字叫做：AnimateToNum，功
能是从某个数字递增或者递减到另外一个数字，并且不管数字如何变化，
都可以在指定的时间内完成。
<!--var AnimateToNum = require("animate-num");-->
持续变化, 边界处理

暂无答案

class AnimateToNum {
   
}

var numAnim = new AnimateToNum({
  animTime:2000, //每次数字变动持续的时间（ms），
  initNum:500, //初始化的数字
  onChange:function(num){
    console.log(num);
  }
});
 
numAnim.toNum(100); 
 从500变化到100，用2000ms的时间，
在onChange回调中会一直从500倒数到100





7. 现提供几个读取文件的方法，不借助全局变量实现一个函数，
 函数可以执行一次后返回一个目录下所有文件中是 .js 后缀的文件列表

递归

var readdirSync = function(dir_path){ return [filename] } 
// 读取一个文件夹下的所有文件夹和文件的路径列表（Array）

var isDirectory = function(path) { return true/false; } 
// 判断一个路径是否是文件夹

var existsSync = function(path){ return true/false;} 
// 判断一个文件/文件夹是否存在
 
var getJSFiles = function(path) {
 
}
getJSFiles('/code/'); // return 一个文件列表的数组



答案
    
    var getJSFiles = function(path) {
        let result = []
            
        if(existsSync(path)) {
             if(isDirectory(path)) {
                const filenames = readdirSync(path)
                filenames.forEach((file, index) => {
                   result = result.concat( getJSFiles(file))
                })
            } else if(/\.js$/.test(path)){
                result.push(path)
            }
        } 
        return result
    }
   





8. 封装一个 CustomFetch 方法，利用原生的 fetch api，但是实现以下几个需求：
所有请求默认带上一个 token，值是 xxx
请求返回的时候，内部解析内容，并且判断 success 字段是否是 true，
如果不是，在 catch 中可以拿到一个Error，message 和 code 是接口返回的对应的内容

CustomFetch("http://api.com/api").then((data)=>{
    console.log(data); // 如果后台返回 true
}).catch((e)=>{
    console.log(e.message); // 输出 “查询错误”
});
 
// 接口的返回模式
{
    success: false,
    code: 'QUERY_ERROR',
    data: {},
    message: '查询错误'
}



```













</x-markdown>
    <script src="https://cdn.bootcss.com/marked/0.3.6/marked.min.js"></script>
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../../js/main.js"></script>
<script>
    //1. 尽可能全面正确的解析一个任意url的所有参数为Object。
    const url = 'http://www.domain.com/?user=anonymous&id=123&city=%E5%8C%97%E4%BA%AC&id=456&id=678&enabled';

    /**
    结果：
    {
    user: 'anonymous',
    id: [123, 456], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型
    city: '北京', // 中文
    enabled: true, // 未指定值的 key 约定值为 true
    }
    */

    const parseParam = (url) => {
        /*
            decodeURI
        */
        let result = {}
        const paramsStr = decodeURI(url).replace(/(.*\?)(.*)/, '$2')
        const paramsArr = paramsStr.split('&')
        
        paramsArr.forEach((param, index) => {
            const paramArr = param.split('=')
            if(paramArr[0] && !paramArr[1]) {
                result[paramArr[0]] = true
            }
            else if(result.hasOwnProperty(paramArr[0])) {
                if(! (result[paramArr[0]] instanceof Array)) {
                    const resultKeyValueArr = []
                    resultKeyValueArr.push(result[paramArr[0]], paramArr[1])
                    result[paramArr[0]] = resultKeyValueArr
                } else {
                    const resultKeyValueArr = result[paramArr[0]]
                    resultKeyValueArr.push(paramArr[1])
                    result[paramArr[0]] = resultKeyValueArr
                }
            
            } else {
                result[paramArr[0]] = paramArr[1]
            }
        })
        console.log(result)

    }
    parseParam(url);

</script>
<script>
    //2. 实现一个最简单的模板引擎
    render('我是{{name}}，年龄{{age}}，性别{{sex}}',{
        name:'姓名',
        age:18
    })

    // 结果： 我是姓名，年龄18，性别undefined。
    function render (template, option) {
        const reg = /{{([^}}]*)}}/g
        const result = template.replace(reg, (match, $1) => option[$1] )
        console.log(result)   
    }

</script>
<script>
    //3.将一个任意长的数字变成逗号分割的格式
	// 1234.56 => "1,234.56" , 123456789 => "123,456,789"
    parseToMoney(123456789.56) // return "123,456,789.56"
    parseToMoney(12347.56) // return "123,456,789.56"
    function parseToMoney(num) {
        const reg = /(\d{1,3})(?=\d{3})/g
        const numStr = num.toString().replace(reg, `$1,`)
        console.log(numStr)
    }

</script>
<script>
    //4. 请用js计算出我到底有多少钱（输出Number类型数字，代码尽量简洁，考虑通用情况）
    const string = "我的账户余额：2,235,467.20"
    howMoney(string)

    function howMoney(str) {
        const reg = /(\d(,|\d|\.)*)/ 
        let money = ''
        str.replace(reg, (match, $1) => money = $1)
        console.log(money)
    }
    
</script>
<script>
   /* 5. 有一个全局变量 a，有一个全局函数 b，
   实现一个方法bindData，执行后，a的任何赋值都会触发b的执行。*/
    const obj = {
        a: 1
    }
    function b(){
        console.log(this)
        console.log('a的值发生改变')
        console.log('a的值为: ', this.a)
    }
    bindData(obj, b)
    obj.a = 2; // 此时输出 a的值发生改变
    function bindData (target, event) {
       for(let key in target) {
           if(target.hasOwnProperty(key)) {
               (function() {
                   let value = target[key]
                   Object.defineProperty(target, key, {
                       get: function ()  {
                           return value
                       },
                       set: function (_value) {
                           value = _value
                            /*event()*/
                           /*console.log(this)*/
                           event.call(this)
                       }
                   })
               })()
           }
       }
    }
</script>
<script>
    /*     
    实现一个 js 的 class ，名字叫做：AnimateToNum，功
    能是从某个数字递增或者递减到另外一个数字，并且不管数字如何变化，
    都可以在指定的时间内完成。
    持续变化, 边界处理
    */
    /*var AnimateToNum = require("animate-num")*/

    class AnimateToNum {
        constructor(props) {
            /*console.log(props)
            console.log(this)*/
            
            
        }
        toNum (num) {
            /*console.log(num)*/
        }
    }

    var numAnim = new AnimateToNum({
    animTime:2000, //每次数字变动持续的时间（ms），
    initNum:500, //初始化的数字
    onChange:function(num){
        console.log(num);
    }
    });
    
    numAnim.toNum(100); 
    /* 
    从500变化到100，用2000ms的时间，
    在onChange回调中会一直从500倒数到100
    */
</script>
<script>
    /*7. 现提供几个读取文件的方法，不借助全局变量实现一个函数，
    函数可以执行一次后返回一个目录下所有文件中是 .js 后缀的文件列表
        递归
    */
   var readdirSync = function(dir_path){ return ['filename'] } 
    // 读取一个文件夹下的所有文件夹和文件的路径列表（Array）

    var isDirectory = function(path) { return true/false; } 
    // 判断一个路径是否是文件夹

    var existsSync = function(path){ return true/false;} 
    // 判断一个文件/文件夹是否存在
    
    var getJSFiles = function(path) {
    
    }
    getJSFiles('/code/'); // return 一个文件列表的数组
            

    
    // 判断一个文件/文件夹是否存在
    var getJSFiles = function(path) {
        let result = []     
        if(existsSync(path)) {
             if(isDirectory(path)) {
                const filenames = readdirSync(path)
                filenames.forEach((file, index) => {
                 //   result = result.concat( getJSFiles(file))
                })
            } else if(/\.js$/.test(path)){
                result.push(path)
            }
        } 
        return result
    }
    getJSFiles('/code/') // return 一个文件列表的数组

</script>
<script>
    /*
    8. 封装一个 CustomFetch 方法，利用原生的 fetch api，但是实现以下几个需求：
所有请求默认带上一个 token，值是 xxx
请求返回的时候，内部解析内容，并且判断 success 字段是否是 true，
如果不是，在 catch 中可以拿到一个Error，message 和 code 是接口返回的对应的内容
*/

CustomFetch("http://api.com/api").then((data)=>{
    console.log(data); // 如果后台返回 true
}).catch((e)=>{
    console.log(e.message); // 输出 “查询错误”
});
 
// 接口的返回模式
{
    success: false,
    code: 'QUERY_ERROR',
    data: {},
    message: '查询错误'
}





</script>
</body>
</html>