<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../style/default.css">
    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
</head>
<body>
<x-markdown>

# 导航

* [返回Github](https://github.com/LDQ-first/frontend)
* [返回首页](../index.html)



## Array API


```



var a = [2, 1, 3]

a.forEach((item, index) => {
    console.log(item, index)
})

var b = a.map((item, index) => {
    return item * 2
}) //生成新数组
console.log(a,b)

var c = a.every((item, index) => {
    if(item < 6) {
        return true
    }
}) //判断所有元素是否符合条件
console.log(a,c)


var d = a.some ((item, index) => {
    if(item < 2) {
        return true
    }
}) //判断是否至少有一个元素符合条件
console.log(a,d)

var e = a.sort((a, b) => {
    return a - b
}) //排序
console.log(a,e)



var f = a.filter((item, index) => {
    if(item % 2 === 0) {
        return true
    }
})
console.log(a, f)


2 0
1 1
3 2
[2, 1, 3] [4, 2, 6]
[2, 1, 3] true
[2, 1, 3] true
[1, 2, 3] [1, 2, 3]
[1, 2, 3] [2] 



var a = [1, 2, 3];

typeof a // "object"
Array.isArray(a) // true


var a = [1, 2, 3];
a.valueOf() // [1, 2, 3]  数组本身




var a = [1, 2, 3];
a.toString() // "1,2,3"

var a = [1, 2, 3, [4, 5, 6]];
a.toString() // "1,2,3,4,5,6"



push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。

var a = [];

a.push(1) // 1
a.push('a') // 2
a.push(true, {}) // 4
a // [1, 'a', true, {}]




pop方法用于删除数组的最后一个元素，并返回该元素。

var a = ['a', 'b', 'c'];

a.pop() // 'c'
a // ['a', 'b']




join方法以参数作为分隔符，将所有数组成员组成一个字符串返回。


var a = [1, 2, 3, 4];

a.join(' ') // '1 2 3 4'
a.join(' | ') // "1 | 2 | 3 | 4"
a.join() // "1,2,3,4"


如果数组成员是undefined或null或空位，会被转成空字符串。

[undefined, null].join('#')
// '#'

['a',, 'b'].join('-')
// 'a--b'


concat方法用于多个数组的合并。它将新数组的成员，
添加到原数组的尾部，然后返回一个新数组，原数组不变。



['hello'].concat(['world'])
// ["hello", "world"]

['hello'].concat(['world'], ['!'])
// ["hello", "world", "!"]


[1, 2, 3].concat(4, 5, 6)
// [1, 2, 3, 4, 5, 6]

// 等同于
[1, 2, 3].concat(4, [5, 6])
[1, 2, 3].concat([4], [5, 6])




shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。

var a = ['a', 'b', 'c'];

a.shift() // 'a'
a // ['b', 'c']





unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。


var a = ['a', 'b', 'c'];

a.unshift('x'); // 4
a // ['x', 'a', 'b', 'c']


var arr = [ 'c', 'd' ];
arr.unshift('a', 'b') // 4
arr // [ 'a', 'b', 'c', 'd' ]





reverse方法用于颠倒数组中元素的顺序，返回改变后的数组。注意，该方法将改变原数组

var a = ['a', 'b', 'c'];

a.reverse() // ["c", "b", "a"]
a // ["c", "b", "a"]




slice方法用于提取原数组的一部分，返回一个新数组，原数组不变。

它的第一个参数为起始位置（从0开始），
第二个参数为终止位置（但该位置的元素本身不包括在内）。
如果省略第二个参数，则一直返回到原数组的最后一个成员。


// 格式
arr.slice(start_index, upto_index);

// 用法
var a = ['a', 'b', 'c'];

a.slice(0) // ["a", "b", "c"]
a.slice(1) // ["b", "c"]
a.slice(1, 2) // ["b"]
a.slice(2, 6) // ["c"]
a.slice() // ["a", "b", "c"]





Array.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })
// ['a', 'b']

Array.prototype.slice.call(document.querySelectorAll("div"));
Array.prototype.slice.call(arguments);



splice方法用于删除原数组的一部分成员，
并可以在被删除的位置添加入新的数组成员，
返回值是被删除的元素。
注意，该方法会改变原数组。

splice的第一个参数是删除的起始位置，
第二个参数是被删除的元素个数。
如果后面还有更多的参数，
则表示这些就是要被插入数组的新元素。




// 格式
arr.splice(index, count_to_remove, addElement1, addElement2, ...);

// 用法
var a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.splice(4, 2) // ["e", "f"]
a // ["a", "b", "c", "d"]


var a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.splice(4, 2, 1, 2) // ["e", "f"]
a // ["a", "b", "c", "d", 1, 2]



var a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.splice(-4, 2) // ["c", "d"]



var a = [1, 1, 1];

a.splice(1, 0, 2) // []
a // [1, 2, 1, 1]




var a = [1, 2, 3, 4];
a.splice(2) // [3, 4]
a // [1, 2]




sort方法对数组成员进行排序，默认是按照字典顺序排序。
排序后，原数组将被改变。


['d', 'c', 'b', 'a'].sort()
// ['a', 'b', 'c', 'd']

[4, 3, 2, 1].sort()
// [1, 2, 3, 4]

[11, 101].sort()
// [101, 11]

[10111, 1101, 111].sort()
// [10111, 1101, 111]





[10111, 1101, 111].sort(function (a, b) {
  return a - b;
})
// [111, 1101, 10111]

[
  { name: "张三", age: 30 },
  { name: "李四", age: 24 },
  { name: "王五", age: 28  }
].sort(function (o1, o2) {
  return o1.age - o2.age;
})
// [
//   { name: "李四", age: 24 },
//   { name: "王五", age: 28  },
//   { name: "张三", age: 30 }
// ]









var arr = ['a', 'b', 'c'];

arr['0'] // 'a'
arr[0] // 'a'




var a = [];

a['1000'] = 'abc';
a[1000] // 'abc'

a[1.00] = 6;
a[1] // 6



var arr = [1, 2, 3];
arr.0 // SyntaxError



['a', 'b', 'c'].length // 3



var arr = ['a', 'b'];
arr.length // 2

arr[2] = 'c';
arr.length // 3

arr[9] = 'd';
arr.length // 10

arr[1000] = 'e';
arr.length // 1001


var arr = [ 'a', 'b', 'c' ];
arr.length // 3

arr.length = 2;
arr // ["a", "b"]




var arr = [ 'a', 'b', 'c' ];

arr.length = 0;
arr // []



var a = ['a'];

a.length = 3;
a[1] // undefined



var a = [];

a['p'] = 'abc';
a.length // 0

a[2.1] = 'abc';
a.length // 0



如果一个对象的所有键名都是正整数或零，
并且有length属性，那么这个对象就很像数组，
语法上称为“类似数组的对象”（array-like object）。

var obj = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
};


obj[0] // 'a'
obj[1] // 'b'
obj.length // 3
obj.push('d') // TypeError: obj.push is not a function




var obj = {
  length: 0
};
obj[3] = 'd';
obj.length // 0



var a = [1, , 1];
a.length // 3



var a = [1, 2, 3];
delete a[1];

a[1] // undefined
a.length // 3





var a = [, , ,];

a.forEach(function (x, i) {
  console.log(i + '. ' + x);
})
// 不产生任何输出

for (var i in a) {
  console.log(i);
}
// 不产生任何输出

Object.keys(a)
// []






var a = [undefined, undefined, undefined];

a.forEach(function (x, i) {
  console.log(i + '. ' + x);
});
// 0. undefined
// 1. undefined
// 2. undefined

for (var i in a) {
  console.log(i);
}
// 0
// 1
// 2

Object.keys(a)
// ['0', '1', '2']





reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。

它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），
reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。

这两个方法的第一个参数都是一个函数。该函数接受以下四个参数。

累积变量，默认为数组的第一个成员
当前变量，默认为数组的第二个成员
当前位置（从0开始）
原数组
这四个参数之中，只有前两个是必须的，后两个则是可选的。

下面的例子求数组成员之和。


[1, 2, 3, 4, 5].reduce(function(x, y){
  console.log(x, y)
  return x + y;
});
// 1 2
// 3 3
// 6 4
// 10 5
//最后结果：15


var arr = [3, 4, 5, 6, 10]

Array.prototype.sum = function (){
  return this.reduce(function (pre, value) {
    return pre + value
  })
}

arr.sum()
// 28




[1, 2, 3, 4, 5].reduce(function(x, y){
  return x + y;
}, 10);
// 25




function add(prev, cur) {
  return prev + cur;
}

[].reduce(add)
// TypeError: Reduce of empty array with no initial value
[].reduce(add, 1)
// 1





function substract(prev, cur) {
  return prev - cur;
}

[3, 2, 1].reduce(substract) // 0
[3, 2, 1].reduceRight(substract) // -4





indexOf方法返回给定元素在数组中第一次出现的位置

var a = ['a', 'b', 'c']

a.indexOf('b') // 1
a.indexOf('y') // -1



indexOf方法还可以接受第二个参数，表示搜索的开始位置。

['a', 'b', 'c'].indexOf('a', 1) // -1

上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。




lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。

var a = [2, 5, 9, 2];
a.lastIndexOf(2) // 3
a.lastIndexOf(7) // -1



注意，如果数组中包含NaN，这两个方法不适用，即无法确定数组成员是否包含NaN。

[NaN].indexOf(NaN) // -1
[NaN].lastIndexOf(NaN) // -1





- 链式使用


var users = [
  {name: 'tom', email: 'tom@example.com'},
  {name: 'peter', email: 'peter@example.com'}
];

users
.map(function (user) {
  return user.email
})
.filter(function (email) {
  return /^t/.test(email)
})
.forEach(alert)
// 弹出tom@example.com









```




[参考1](http://javascript.ruanyifeng.com/stdlib/array.html#toc18)















</x-markdown>
    <script src="https://cdn.bootcss.com/marked/0.3.6/marked.min.js"></script>
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../js/main.js"></script>
</body>
</html>